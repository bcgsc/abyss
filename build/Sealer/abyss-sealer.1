.\" Automatically generated by Pandoc 2.10.1
.\"
.TH "abyss-sealer" "1" "2014-11-13" "ABySS" "ABySS"
.hy
.SH Name
.PP
abyss-sealer - Close gaps within scaffolds
.SH Synopsis
.PP
\f[C]abyss-sealer -b <Bloom filter size> -k <kmer size> -k <kmer size>... -o <output_prefix> -S <path to scaffold file> [options]... <reads1> [reads2]...\f[R]
.PP
For example:
.PP
\f[C]abyss-sealer -b20G -k64 -k80 -k96 -k112 -k128 -o test -S scaffold.fa read1.fa read2.fa\f[R]
.SH Description
.PP
Sealer is an application of Konnector that closes intra-scaffold gaps.
It performs three sequential functions.
First, regions with Ns are identified from an input scaffold.
Flanking nucleotues (2 x 100bp) are extracted from those regions while
respecting the strand (5\[cq] to 3\[cq]) direction on the sequence
immediately downstream of each gap.
In the second step, flanking sequence pairs are used as input to
Konnector along with a set of reads with a high level of coverage
redundancy.
Ideally, the reads should represent the original dataset from which the
draft assembly is generated, or further whole genome shotgun (WGS)
sequencing data generated from the same sample.
Within Konnector, the input WGS reads are used to populate a Bloom
filter, tiling the reads with a sliding window of length \f[I]k\f[R],
thus generating a probabilistic representation of all the
\f[I]k\f[R]-mers in the reads.
Konnector also uses crude error removal and correctional algorithms,
eliminating singletons (\f[I]k\f[R]-mers that are observed only once)
and fixing base mismatches in the flanking sequence pairs.
Sealer launches Konnector processes using a user-input range of
\f[I]k\f[R]-mer lengths.
In the third and final operation, successfully merged sequences are
inserted into the gaps of the original scaffolds, and Sealer outputs a
new gap-filled scaffold file.
.SH Installation
.PP
See ABySS installation instructions.
.SH How to run as stand-alone application
.PP
\f[C]abyss-sealer [-b bloom filter size][-k values...] [-o outputprefix] [-S assembly file] [options...] [reads...]\f[R]
.PP
Sealer requires the following information to run: - draft assembly -
user-supplied \f[I]k\f[R] values (>0) - output prefix - WGS reads (for
building Bloom Filters)
.SH Sample commands
.PP
Without pre-built bloom filters:
.PP
\f[C]abyss-sealer -b20G -k64 -k96 -o run1 -S test.fa read1.fq.gz read2.fq.gz\f[R]
.PP
With pre-built bloom filters:
.PP
\f[C]abyss-sealer -k64 -k96 -o run1 -S test.fa -i k64.bloom -i k96.bloom read1.fq.gz read2.fq.gz\f[R]
.PP
Reusable Bloom filters can be pre-built with
\f[C]abyss-bloom build\f[R], e.g.:
.PP
\f[C]abyss-bloom build -vv -k64 -j12 -b20G -l2 k64.bloom read1.fq.gz read2.fq.gz\f[R]
.PP
Note: when using pre-built bloom filters generated by
\f[C]abyss-bloom build\f[R], Sealer must be compiled with the same
\f[C]maxk\f[R] value that \f[C]abyss-bloom\f[R] was compiled with.
For example, if a Bloom filter was built with a \f[C]maxk\f[R] of 64,
Sealer must be compiled with a \f[C]maxk\f[R] of 64 as well.
If different values are used between the pre-built bloom filter and
Sealer, any sequences generated will be nonsensical and incorrect.
.SH Output files
.IP \[bu] 2
prefix_log.txt
.IP \[bu] 2
prefix_scaffold.fa
.IP \[bu] 2
prefix_merged.fa
.IP \[bu] 2
prefix_flanks_1.fq -> if \f[C]--print-flanks\f[R] option used
.IP \[bu] 2
prefix_flanks_2.fq -> if \f[C]--print-flanks\f[R] option used
.PP
The log file contains results of each Konnector run.
The structure of one run is as follows:
.IP \[bu] 2
## unique gaps closed for k##
.IP \[bu] 2
No start/goal kmer: ###
.IP \[bu] 2
No path: ###
.IP \[bu] 2
Unique path: ###
.IP \[bu] 2
Multiple paths: ###
.IP \[bu] 2
Too many paths: ###
.IP \[bu] 2
Too many branches: ###
.IP \[bu] 2
Too many path/path mismatches: ###
.IP \[bu] 2
Too many path/read mismatches: ###
.IP \[bu] 2
Contains cycle: ###
.IP \[bu] 2
Exceeded mem limit: ###
.IP \[bu] 2
Skipped: ###
.IP \[bu] 2
### flanks left
.IP \[bu] 2
k## run complete
.IP \[bu] 2
Total gaps closed so far = ###
.PP
The scaffold.fa file is a gap-filled version of the draft assembly
inserted into Sealer.
The merged.fa file contains every newly generated sequence that were
inserted into gaps, including the flanking sequences.
Negative sizes of new sequences indicate Konnector collapsed the pair of
flanking sequences.
For example:
.PP
>[scaffold ID]_[original start position of gap on scaffold]_[size of new
sequence] ACGCGACGAGCAGCGAGCACGAGCAGCGACGAGCGACGACGAGCAGCGACGAGCG
.PP
If \f[C]--print-flanks\f[R] option is enabled, Sealer outputs the
flanking sequences used to insert into Konnector.
This may be useful should users which to double check if this tool is
extracting the correct sequences surrounding gaps.
The structure of these files are as follows:
.PP
>[scaffold ID]_[original start position of gap on scaffold]_[size of
gap]/[1 or 2 indicating whether left or right flank]
GCTAGCTAGCTAGCTGATCGATCGTAGCTAGCTAGCTGACTAGCTGATCAGTCGA
.SH How to optimize for gap closure
.PP
To optimize Sealer, users can observe the log files generated after a
run and adjust parameters accordingly.
If \f[I]k\f[R] runs are showing gaps having too many paths or branches,
consider increasing \f[C]-P\f[R] or \f[C]-B\f[R] parameters,
respectively.
.PP
Also consider increasing the number of \f[I]k\f[R] values used.
Generally, large \f[I]k\f[R]-mers are better able to address highly
repetitive genomic regions, while smaller \f[I]k\f[R]-mers are better
able to resolve areas of low coverage.
.SH Runtime and memory usage
.PP
More \f[I]k\f[R] values mean more bloom filters will be required, which
will increase runtime as it takes time to build/load each bloom filter
at the beginning of each \f[I]k\f[R] run.
Memory usage is not affected by using more bloom filters.
.PP
The larger value used for parameters such as \f[C]-P\f[R], \f[C]-B\f[R]
or \f[C]-F\f[R] will increase runtime.
.SH Options
.PP
Parameters of \f[C]abyss-sealer\f[R]
.IP \[bu] 2
\f[C]--print-flanks\f[R]: outputs flank files
.IP \[bu] 2
\f[C]-S\f[R],\f[C]--input-scaffold=FILE\f[R]: load scaffold from FILE
.IP \[bu] 2
\f[C]-L\f[R],\f[C]--flank-length=N\f[R]: length of flanks to be used as
pseudoreads [\f[C]100\f[R]]
.IP \[bu] 2
\f[C]-j\f[R],\f[C]--threads=N\f[R]: use N parallel threads [1]
.IP \[bu] 2
\f[C]-k\f[R],\f[C]--kmer=N\f[R]: the size of a k-mer
.IP \[bu] 2
\f[C]-b\f[R],\f[C]--bloom-size=N\f[R]: size of bloom filter.
Required when not using pre-built Bloom filter(s).
.IP \[bu] 2
\f[C]-B\f[R],\f[C]--max-branches=N\f[R]: max branches in de Bruijn graph
traversal; use `nolimit' for no limit [1000]
.IP \[bu] 2
\f[C]-d\f[R],\f[C]--dot-file=FILE\f[R]: write graph traversals to a DOT
file
.IP \[bu] 2
\f[C]-e\f[R],\f[C]--fix-errors\f[R]: find and fix single-base errors
when reads have no kmers in bloom filter [disabled]
.IP \[bu] 2
\f[C]-f\f[R],\f[C]--min-frag=N\f[R]: min fragment size in base pairs [0]
.IP \[bu] 2
\f[C]-F\f[R],\f[C]--max-frag=N\f[R]: max fragment size in base pairs
[1000]
.IP \[bu] 2
\f[C]-i\f[R],\f[C]--input-bloom=FILE\f[R]: load bloom filter from FILE
.IP \[bu] 2
\f[C]--mask\f[R]: mask new and changed bases as lower case
.IP \[bu] 2
\f[C]--no-mask\f[R]: do not mask bases [default]
.IP \[bu] 2
\f[C]--chastity\f[R]: discard unchaste reads [default]
.IP \[bu] 2
\f[C]--no-chastity\f[R]: do not discard unchaste reads
.IP \[bu] 2
\f[C]--trim-masked\f[R]: trim masked bases from the ends of reads
.IP \[bu] 2
\f[C]--no-trim-masked\f[R]: do not trim masked bases from the ends of
reads [default]
.IP \[bu] 2
\f[C]-l\f[R],\f[C]--long-search\f[R]: start path search as close as
possible to the beginnings of reads.
Takes more time but improves results when bloom filter false positive
rate is high [disabled]
.IP \[bu] 2
\f[C]-m,\f[R]\[en]flank-mismatches=N\[ga]: max mismatches between paths
and flanks; use `nolimit' for no limit [nolimit]
.IP \[bu] 2
\f[C]-M,\f[R]\[en]max-mismatches=N\[ga]: max mismatches between all
alternate paths; use `nolimit' for no limit [nolimit]
.IP \[bu] 2
\f[C]-n\f[R]\[en]no-limits\[ga]: disable all limits; equivalent to `-B
nolimit -m nolimit -M nolimit -P nolimit'
.IP \[bu] 2
\f[C]-o,\f[R]\[en]output-prefix=FILE\[ga]: prefix of output FASTA files
[required]
.IP \[bu] 2
\f[C]-P,\f[R]\[en]max-paths=N\[ga]: merge at most N alternate paths; use
`nolimit' for no limit [2]
.IP \[bu] 2
\f[C]-q,\f[R]\[en]trim-quality=N\[ga]: trim bases from the ends of reads
whose quality is less than the threshold
.IP \[bu] 2
\f[C]--standard-quality\f[R]: zero quality is \[ga]!\[cq] (33) default
for FASTQ and SAM files
.IP \[bu] 2
\f[C]--illumina-quality\f[R]: zero quality is \[ga]\[at]\[cq] (64)
default for qseq and export files
.IP \[bu] 2
\f[C]-r,\f[R]\[en]read-name=STR\[ga]: only process reads with names that
contain STR
.IP \[bu] 2
\f[C]-s,\f[R]\[en]search-mem=N\[ga]: mem limit for graph searches;
multiply by the number of threads (-j) to get the total mem used for
graph traversal [500M]
.IP \[bu] 2
\f[C]-t,\f[R]\[en]trace-file=FILE\[ga]: write graph search stats to FILE
.IP \[bu] 2
\f[C]-v,\f[R]\[en]verbose\[ga]: display verbose output
.IP \[bu] 2
\f[C]--help\f[R]: display this help and exit
.IP \[bu] 2
\f[C]--version\f[R]: output version information and exit
.PP
\f[I]k\f[R] is the size of \f[I]k\f[R]-mer for the de Bruijn graph.
You may specify multiple values of \f[I]k\f[R], which will increase the
number of gaps closed at the cost of increased run time.
Multiple values of \f[I]k\f[R] ought to be specified in increasing
order, as lower values of \f[I]k\f[R] have fewer coverage gaps and are
less likely to misassemble.
.PP
\f[I]P\f[R] is the threshold for number of paths allowed to be
traversed.
When set to 10, Konnector will attempt to close gaps even when there are
10 different paths found.
It would attempt to create a consensus sequence between these paths.
The default setting is 2.
.SH AUTHORS
Daniel Paulino.
